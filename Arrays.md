---

---

---
| Question                                                | Notes                                                                                                                                                                                                                                                                                                                                                                                                     | Pattern                  | Runtime  | Spacetime | Solution     | Solved?                     |
| ------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | -------- | --------- | ------------ | --------------------------- |
| Two Sum                                                 | I know how to do this                                                                                                                                                                                                                                                                                                                                                                                     | N/A                      | O(n)     | O(n)      | Not Needed   | Yes                         |
| Container with Most Water                               | I know how to do this                                                                                                                                                                                                                                                                                                                                                                                     | [[Two Pointers]]         | O(n)     | O(1)      | Not Needed   | Yes                         |
| Three Sum                                               | This is Two Sum II but I have to set the target. Be wary of duplicate target values. Also be wary of case where there are multiple solutions for one target. Need to handle case where when we search for more than 1 solution, we may encounter duplicate L and R values                                                                                                                                 | [[Two Pointers]]         | O(n^2)   | O(1)      | Not Needed   | Yes                         |
| Three Sum Closest  e                                    | This is Three Sum but rather than finding 3 values that equal 0, we have a target to look for. Don't need to handle duplicates like before. Think about how we can find our 'best' value. What is our invariant? Recall we want to be as close to the target as possible. How can we adjust L and R accordingly with respect to target?                                                                   | [[Two Pointers]]         | O(n^2)   | O(1)      | Not Needed   | Yes                         |
| 4Sum                                                    | Make a function called kSums where it finds k values that sums to a given target. The base case is 2sum. Iterate over all values and invoke kSums recursively. Iterate over the results of that call and append the current value onto each result subarray. Append each result to our overall result array.                                                                                              | [[Two Pointers]]         | O(n^3)   | O(1)      | Not Needed   | Yes                         |
| Remove Duplicates From Sorted Array                     | Need a slow pointer that keeps track of our last duplicate value. Move the faster pointer over until we find a non-duplicate value. Then swap and increment slow pointer.                                                                                                                                                                                                                                 | [[Two Pointers]]         | O(n)     | O(1)      | Not Needed   | Yes                         |
| Next Permutation                                        | Find first item in the list that is less than the following item in the list. If the first item happens to be at index 0, this means the entire list is sorted so we can just reverse. For all other cases, find the element that would follow this 'first' element in sorted order. Swap those two values. Reverse everything from the 'first' value to the end                                          | N/A                      | O(n)     | O(1)      | Review notes | No                          |
| Search in Sorted Rotated Array                          | Determine what part of the array we are in. We have two conditions: if nums[left] <= nums[mid] or the opposite. From there it should be obvious how to handle the two subcases in each case (normal subcase vs weird subcase).                                                                                                                                                                            | [[Binary Search]]        | O(logn)  | O(1)      | Review Notes | No                          |
| Find First and Last Position of Element in Sorted Array | We will first do binary search to find the lower bound and then do binary search to find the upper bound. Only change is once we find our target value, we will either decrement/increment our index depending on the bound we want. Return this index for our result                                                                                                                                     | [[Binary Search]]        | O(logn)  | O(1)      | Not Needed   | Didn't get optimal solution |
| Search Insert Position                                  | Do normal binary search. If the target exists return its index otherwise return left.                                                                                                                                                                                                                                                                                                                     | [[Binary Search]]        | O(logn)  | O(1)      | Not Needed   | Yes                         |
| Valid Sudoku                                            | Have three hashmaps where the key is the index of the row,column, or tuple corresponding to what 'box' we are currently on and the value is a set.                                                                                                                                                                                                                                                        | [[Hash]]                 | O(m x n) | O(n)      | Not Needed   | Yes                         |
| Combination Sum                                         | Recursively invoke our aux function while iterating from index to the end of the candidates list. Base case is if we exceed target or equal target. Don't do the pushing/popping thing your used to.                                                                                                                                                                                                      | [[Backtracking]]         | O(2^n)   | O(2^n)    | Not Needed   | Yes                         |
| Combination Sum II                                      | Same as the above except if i > index and candidates[i] == candidates[i-1] then we skip the iteration in our aux function. We also pass in index+1 to our aux function                                                                                                                                                                                                                                    | [[Backtracking]]         | O(2^n)   | O(2^n)    | Not Needed   | Yes                         |
| Permutations                                            | Define an aux function where you iterate over all candidates and invoke the aux recursive call for all candidates we haven't visited in this path. Add element to visited before the call and remove element from visited after the call. Visualize this by drawing a decision tree                                                                                                                       | [[Backtracking]]         | O(n!)    | O(n!)     | Not Needed   | Yes                         |
| Permutations II                                         | Same as above just use a set                                                                                                                                                                                                                                                                                                                                                                              | [[Backtracking]]         | O(n!)    | O(n!)     | Not Needed   | Yes                         |
| Jump Game II                                            | Get the max of the current maximum distance vs furthest the distance we can get to using this step. Base case is obvious. We also want to keep track of our 'level' -> determines how many values we can check at a given time (think like a queue in bfs). If we reach the end of our level, increment our step count and set the level to our distance which is already maximized from the above steps. | [[Breadth First Search]] | O(n)     | O (1)     | Not Needed   | No                          |
| Group Anagrams                                          | For each string, sort it and add a mapping to the dict (key -> list of strings associated with this string). Iterate over keys and add each value to our result set.                                                                                                                                                                                                                                      | [[Hash]]                 | O(n)     | O(n)      | Not Needed   | Yes                         |
| Maximum Subarray                                        | Kadane's Algo                                                                                                                                                                                                                                                                                                                                                                                             | N/A                      | O(n)     | O(1)      | Not Needed   | Yes                            |

